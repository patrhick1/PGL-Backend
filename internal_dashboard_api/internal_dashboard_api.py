import uuid
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime, date
import logging
import asyncpg
from passlib.context import CryptContext
import contextlib # For async context manager

# Adjust import path based on your project structure
# Assuming db_service_pg.py is in the parent directory (project root)
import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
import db_service_pg # This should now find db_service_pg.py in the root

# For type hinting the pool if passed via dependency
from asyncpg.pool import Pool

logger = logging.getLogger(__name__)

# Placeholder for database connection and service functions
# You will need to integrate your db_service_pg.py here
# For now, we'll use a mock DB for demonstration purposes in the CRUD operations
# and define where db_service_pg functions would be called.

# --- Pydantic Models for Campaigns ---

class CampaignBase(BaseModel):
    person_id: int # Foreign key to PEOPLE table
    attio_client_id: Optional[uuid.UUID] = None
    campaign_name: str
    campaign_type: Optional[str] = None
    campaign_bio: Optional[str] = None # Link to GDoc or text
    campaign_angles: Optional[str] = None # Link to GDoc or text
    campaign_keywords: Optional[List[str]] = None # Stored as TEXT[] in DB
    compiled_social_posts: Optional[str] = None # Link to GDoc or text
    podcast_transcript_link: Optional[str] = None # Link to GDoc
    compiled_articles_link: Optional[str] = None # Link to GDoc
    mock_interview_trancript: Optional[str] = None # Link to GDoc or text
    # embedding: Optional[List[float]] = None # VECTOR(1536) - Handled separately if needed
    start_date: Optional[date] = None
    end_date: Optional[date] = None
    goal_note: Optional[str] = None
    media_kit_url: Optional[str] = None

class CampaignCreate(CampaignBase):
    campaign_id: uuid.UUID = Field(default_factory=uuid.uuid4) # Client can provide or defaults to new UUID

class CampaignUpdate(BaseModel):
    person_id: Optional[int] = None
    attio_client_id: Optional[uuid.UUID] = None
    campaign_name: Optional[str] = None
    campaign_type: Optional[str] = None
    campaign_bio: Optional[str] = None
    campaign_angles: Optional[str] = None
    campaign_keywords: Optional[List[str]] = None
    compiled_social_posts: Optional[str] = None
    podcast_transcript_link: Optional[str] = None
    compiled_articles_link: Optional[str] = None
    mock_interview_trancript: Optional[str] = None
    start_date: Optional[date] = None
    end_date: Optional[date] = None
    goal_note: Optional[str] = None
    media_kit_url: Optional[str] = None

class CampaignInDB(CampaignBase):
    campaign_id: uuid.UUID
    created_at: datetime

    class Config:
        from_attributes = True # For SQLAlchemy or other ORMs; helps map to DB objects

# --- Pydantic Models for People ---

class PersonBase(BaseModel):
    company_id: Optional[int] = None # Foreign key to COMPANIES table
    full_name: Optional[str] = None
    email: str # Email is required and should be unique
    linkedin_profile_url: Optional[str] = None
    twitter_profile_url: Optional[str] = None
    instagram_profile_url: Optional[str] = None
    tiktok_profile_url: Optional[str] = None
    dashboard_username: Optional[str] = None
    # dashboard_password_hash: Optional[str] = None # Typically not exposed or updated directly via general API
    attio_contact_id: Optional[uuid.UUID] = None
    role: Optional[str] = None

class PersonCreate(PersonBase):
    # For creating, we might want to allow setting a password, which then gets hashed by the backend
    # For simplicity here, we'll omit direct password handling in this model.
    # If dashboard_username is set, a process should handle password creation/hashing.
    pass

class PersonUpdate(BaseModel):
    company_id: Optional[int] = None
    full_name: Optional[str] = None
    email: Optional[str] = None # Allow email update, though uniqueness must be handled
    linkedin_profile_url: Optional[str] = None
    twitter_profile_url: Optional[str] = None
    instagram_profile_url: Optional[str] = None
    tiktok_profile_url: Optional[str] = None
    dashboard_username: Optional[str] = None
    # dashboard_password_hash: should be updated via a separate, secure mechanism (e.g., password reset flow)
    attio_contact_id: Optional[uuid.UUID] = None
    role: Optional[str] = None

class PersonInDB(PersonBase):
    person_id: int # Auto-generated by SERIAL
    created_at: datetime
    updated_at: datetime
    dashboard_password_hash: Optional[str] = None # Include for reading, but not direct update via PersonUpdate

    class Config:
        from_attributes = True

class PersonSetPassword(BaseModel):
    password: str = Field(min_length=8, description="New password for the person (min 8 characters)")

# --- Pydantic Models for Media (Fully Updated for 37+ columns) ---

class MediaBase(BaseModel):
    # Core fields from schema
    name: Optional[str] = None
    title: Optional[str] = None # Often same as name, but can differ
    rss_url: Optional[str] = None 
    rss_feed_url: Optional[str] = None # Explicitly from your schema list
    website: Optional[str] = None
    description: Optional[str] = None
    ai_description: Optional[str] = None
    contact_email: Optional[str] = None
    language: Optional[str] = None
    category: Optional[str] = None # Primary category string
    image_url: Optional[str] = None
    
    # Stats & IDs from schema
    company_id: Optional[int] = None # FK to companies
    avg_downloads: Optional[int] = None # General field, might map to audience_size
    audience_size: Optional[int] = None # Specifically from Podscan reach
    total_episodes: Optional[int] = None
    itunes_id: Optional[str] = None # Stored as TEXT in DB
    podcast_spotify_id: Optional[str] = None # Renamed from spotify_id for clarity
    listen_score: Optional[float] = None # REAL in DB
    listen_score_global_rank: Optional[int] = None # INTEGER in DB (was text before, ensure DB is int)
    itunes_rating_average: Optional[float] = None
    itunes_rating_count: Optional[int] = None
    spotify_rating_average: Optional[float] = None
    spotify_rating_count: Optional[int] = None

    # Status & Source from schema
    fetched_episodes: Optional[bool] = Field(default=False)
    source_api: Optional[str] = None # e.g., "ListenNotes", "PodscanFM", "Mixed"
    api_id: Optional[str] = None # ID from the source_api (e.g. ListenNotes ID, Podscan podcast_id)
    
    # Dates from schema
    last_posted_at: Optional[datetime] = None # TIMESTAMPTZ
    
    # Social Links from schema
    podcast_twitter_url: Optional[str] = None
    podcast_linkedin_url: Optional[str] = None
    podcast_instagram_url: Optional[str] = None
    podcast_facebook_url: Optional[str] = None
    podcast_youtube_url: Optional[str] = None
    podcast_tiktok_url: Optional[str] = None
    podcast_other_social_url: Optional[str] = None
    
    # embedding is intentionally omitted from general CRUD models

class MediaCreate(MediaBase):
    name: str # Name is required to create a media entry
    # rss_url is highly recommended for deduplication.
    # Consider making source_api and api_id required if known at creation.
    pass

class MediaUpdate(BaseModel):
    name: Optional[str] = None
    title: Optional[str] = None
    rss_url: Optional[str] = None
    rss_feed_url: Optional[str] = None
    website: Optional[str] = None
    description: Optional[str] = None
    ai_description: Optional[str] = None
    contact_email: Optional[str] = None
    language: Optional[str] = None
    category: Optional[str] = None
    image_url: Optional[str] = None
    company_id: Optional[int] = None
    avg_downloads: Optional[int] = None
    audience_size: Optional[int] = None
    total_episodes: Optional[int] = None
    itunes_id: Optional[str] = None
    podcast_spotify_id: Optional[str] = None
    listen_score: Optional[float] = None
    listen_score_global_rank: Optional[int] = None
    itunes_rating_average: Optional[float] = None
    itunes_rating_count: Optional[int] = None
    spotify_rating_average: Optional[float] = None
    spotify_rating_count: Optional[int] = None
    fetched_episodes: Optional[bool] = None
    source_api: Optional[str] = None
    api_id: Optional[str] = None
    last_posted_at: Optional[datetime] = None
    podcast_twitter_url: Optional[str] = None
    podcast_linkedin_url: Optional[str] = None
    podcast_instagram_url: Optional[str] = None
    podcast_facebook_url: Optional[str] = None
    podcast_youtube_url: Optional[str] = None
    podcast_tiktok_url: Optional[str] = None
    podcast_other_social_url: Optional[str] = None

class MediaInDB(MediaBase):
    media_id: int # Auto-generated by SERIAL
    created_at: datetime
    # All fields from MediaBase are inherited

    class Config:
        from_attributes = True

# --- Pydantic Models for Match Suggestions ---

class MatchSuggestionBase(BaseModel):
    campaign_id: uuid.UUID # FK to campaigns table
    media_id: int        # FK to media table
    match_score: Optional[float] = None # NUMERIC can be float
    matched_keywords: Optional[List[str]] = None # TEXT[]
    ai_reasoning: Optional[str] = None
    # client_approved: Optional[bool] = Field(default=False) # Default in DB, no need to always send for create
    # approved_at: Optional[datetime] = None
    status: Optional[str] = Field(default="pending", description="Status: pending, approved, rejected") 

class MatchSuggestionCreate(MatchSuggestionBase):
    # match_id is SERIAL, created_at has default in DB
    # client_approved defaults to FALSE in DB
    # status defaults to 'pending'
    pass

class MatchSuggestionUpdate(BaseModel):
    match_score: Optional[float] = None
    matched_keywords: Optional[List[str]] = None
    ai_reasoning: Optional[str] = None
    client_approved: Optional[bool] = None
    approved_at: Optional[datetime] = None # Can be set when client_approved is set to True
    status: Optional[str] = None

class MatchSuggestionInDB(MatchSuggestionBase):
    match_id: int
    client_approved: bool # Will have a default from DB if not set
    approved_at: Optional[datetime]
    created_at: datetime

    class Config:
        from_attributes = True

# --- FastAPI Application ---

@contextlib.asynccontextmanager
async def lifespan(app: FastAPI):
    # Code to run on startup
    logger.info("FastAPI application startup: Initializing database pool via lifespan...")
    await db_service_pg.init_db_pool()
    logger.info("Database pool initialized successfully via lifespan.")
    yield # This is where the application runs
    # Code to run on shutdown
    logger.info("FastAPI application shutdown: Closing database pool via lifespan...")
    await db_service_pg.close_db_pool()
    logger.info("Database pool closed successfully via lifespan.")

app = FastAPI(
    title="Internal Team Dashboard API",
    description="API for managing podcast outreach campaigns and related entities.",
    version="0.1.0",
    lifespan=lifespan # Use the new lifespan manager
)

# --- Mock Database (Remove this when integrating db_service_pg.py) ---
# This is just for illustrating API functionality without a live DB connection yet.
MOCK_DB_CAMPAIGNS: Dict[uuid.UUID, CampaignInDB] = {}

# --- Dependency for DB connection (to be implemented) ---
# async def get_db_session():
#     # Replace with your actual asyncpg pool or SQLAlchemy session logic
#     # from db_service_pg import get_db_connection # or similar
#     # conn = await get_db_connection()
#     # try:
#     #     yield conn # or session
#     # finally:
#     #     await conn.close() # or session.close()
#     pass

# --- Dependency for DB Pool (Optional if db_service functions get pool themselves) ---
# async def get_database_pool_dependency() -> Pool:
#     return await db_service_pg.get_db_pool()

# --- Password Hashing Utility ---
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

# --- API Endpoints ---

@app.get("/health", summary="Health Check", tags=["General"])
async def health_check():
    """Checks if the API is running."""
    return {"status": "healthy", "message": "API is up and running!"}

# --- Campaign CRUD Endpoints (To be integrated with db_service_pg) ---

@app.post("/campaigns/", response_model=CampaignInDB, status_code=201, summary="Create New Campaign", tags=["Campaigns"])
async def create_campaign_api(campaign: CampaignCreate):
    campaign_dict = campaign.dict()
    try:
        created_db_campaign = await db_service_pg.create_campaign_in_db(campaign_dict)
        if not created_db_campaign:
            raise HTTPException(status_code=500, detail="Failed to create campaign in database.")
        return CampaignInDB(**created_db_campaign) # Validate and return
    except Exception as e:
        logger.exception(f"Error in create_campaign_api for campaign name {campaign.campaign_name}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/campaigns/", response_model=List[CampaignInDB], summary="List All Campaigns", tags=["Campaigns"])
async def list_campaigns_api(skip: int = 0, limit: int = 100):
    try:
        campaigns_from_db = await db_service_pg.get_all_campaigns_from_db(skip=skip, limit=limit)
        return [CampaignInDB(**c) for c in campaigns_from_db]
    except Exception as e:
        logger.exception(f"Error in list_campaigns_api: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/campaigns/{campaign_id}", response_model=CampaignInDB, summary="Get Specific Campaign", tags=["Campaigns"])
async def get_campaign_api(campaign_id: uuid.UUID):
    try:
        campaign_from_db = await db_service_pg.get_campaign_by_id(campaign_id)
        if not campaign_from_db:
            raise HTTPException(status_code=404, detail=f"Campaign with ID {campaign_id} not found.")
        return CampaignInDB(**campaign_from_db)
    except Exception as e:
        logger.exception(f"Error in get_campaign_api for ID {campaign_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.put("/campaigns/{campaign_id}", response_model=CampaignInDB, summary="Update Campaign", tags=["Campaigns"])
async def update_campaign_api(campaign_id: uuid.UUID, campaign_update: CampaignUpdate):
    update_data = campaign_update.dict(exclude_unset=True)
    if not update_data:
        raise HTTPException(status_code=400, detail="No update data provided.")
    try:
        updated_db_campaign = await db_service_pg.update_campaign(campaign_id, update_data)
        if not updated_db_campaign:
            raise HTTPException(status_code=404, detail=f"Campaign with ID {campaign_id} not found or update failed.")
        return CampaignInDB(**updated_db_campaign)
    except Exception as e:
        logger.exception(f"Error in update_campaign_api for ID {campaign_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/campaigns/{campaign_id}", status_code=204, summary="Delete Campaign", tags=["Campaigns"])
async def delete_campaign_api(campaign_id: uuid.UUID):
    try:
        success = await db_service_pg.delete_campaign_from_db(campaign_id)
        if not success:
            raise HTTPException(status_code=404, detail=f"Campaign with ID {campaign_id} not found or delete failed.")
        return # Returns 204 No Content on success
    except Exception as e:
        logger.exception(f"Error in delete_campaign_api for ID {campaign_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# --- Endpoint to Trigger Angles/Bio Generation ---
class AnglesBioTriggerResponse(BaseModel):
    campaign_id: uuid.UUID
    status: str # e.g., "processing_started", "success", "error", "skipped"
    message: str
    details: Optional[Dict[str, Any]] = None

@app.post("/campaigns/{campaign_id}/generate-angles-bio", 
            response_model=AnglesBioTriggerResponse, 
            summary="Trigger Bio & Angles Generation", 
            tags=["Campaigns", "AI Processing"])
async def trigger_angles_bio_generation_api(campaign_id: uuid.UUID):
    # Ensure campaign exists before triggering
    campaign_exists = await db_service_pg.get_campaign_by_id(campaign_id)
    if not campaign_exists:
         raise HTTPException(status_code=404, detail=f"Campaign {campaign_id} not found, cannot trigger generation.")

    # Dynamically import AnglesProcessorPG to avoid circular dependencies if it also imports this API's models
    # Or ensure it's structured to be importable (e.g. angles_processor_pg.py in project root or src/)
    try:
        # Assuming angles_processor_pg.py is in the project root, made accessible by sys.path.append above
        from angles_processor_pg import AnglesProcessorPG 
    except ImportError:
        logger.exception("Failed to import AnglesProcessorPG. Ensure it is in the Python path (e.g., project root).")
        raise HTTPException(status_code=500, detail="Angles processing module not found.")
    
    logger.info(f"Received request to generate angles/bio for campaign_id: {campaign_id}")
    processor = AnglesProcessorPG()
    try:
        # The process_campaign method is async
        result = await processor.process_campaign(str(campaign_id)) # AnglesProcessorPG expects string campaign_id
        
        # Adapt the result from AnglesProcessorPG to AnglesBioTriggerResponse
        response_status = result.get("status", "error")
        response_message = result.get("reason") or result.get("bio_doc_link") or "Processing completed."
        if response_status == "success":
            response_message = f"Successfully generated Bio & Angles for campaign {campaign_id}."

        return AnglesBioTriggerResponse(
            campaign_id=campaign_id,
            status=response_status,
            message=response_message,
            details=result
        )
    except Exception as e:
        logger.exception(f"Unhandled exception during angles/bio generation trigger for campaign {campaign_id}: {e}")
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred during generation: {str(e)}")
    finally:
        processor.cleanup() # Important to release resources like thread pool

# --- People CRUD Endpoints ---

@app.post("/people/", response_model=PersonInDB, status_code=201, summary="Create New Person", tags=["People"])
async def create_person_api(person_data: PersonCreate):
    person_dict = person_data.dict()
    try:
        # Check if email already exists, as it's unique
        existing_person_by_email = await db_service_pg.get_person_by_email_from_db(person_data.email)
        if existing_person_by_email:
            raise HTTPException(status_code=409, detail=f"Person with email {person_data.email} already exists.")
        
        created_db_person = await db_service_pg.create_person_in_db(person_dict)
        if not created_db_person:
            raise HTTPException(status_code=500, detail="Failed to create person in database.")
        return PersonInDB(**created_db_person)
    except asyncpg.exceptions.UniqueViolationError: # Catch UniqueViolation specifically if not caught in db_service
         raise HTTPException(status_code=409, detail=f"Person with email {person_data.email} already exists (unique constraint).")
    except Exception as e:
        logger.exception(f"Error in create_person_api for email {person_data.email}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/people/", response_model=List[PersonInDB], summary="List All People", tags=["People"])
async def list_people_api(skip: int = 0, limit: int = 100):
    try:
        people_from_db = await db_service_pg.get_all_people_from_db(skip=skip, limit=limit)
        return [PersonInDB(**p) for p in people_from_db]
    except Exception as e:
        logger.exception(f"Error in list_people_api: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/people/{person_id}", response_model=PersonInDB, summary="Get Specific Person by ID", tags=["People"])
async def get_person_api(person_id: int):
    try:
        person_from_db = await db_service_pg.get_person_by_id_from_db(person_id)
        if not person_from_db:
            raise HTTPException(status_code=404, detail=f"Person with ID {person_id} not found.")
        return PersonInDB(**person_from_db)
    except Exception as e:
        logger.exception(f"Error in get_person_api for ID {person_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/people/email/{email}", response_model=PersonInDB, summary="Get Specific Person by Email", tags=["People"])
async def get_person_by_email_api(email: str):
    try:
        person_from_db = await db_service_pg.get_person_by_email_from_db(email)
        if not person_from_db:
            raise HTTPException(status_code=404, detail=f"Person with email {email} not found.")
        return PersonInDB(**person_from_db)
    except Exception as e:
        logger.exception(f"Error in get_person_by_email_api for email {email}: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.put("/people/{person_id}", response_model=PersonInDB, summary="Update Person", tags=["People"])
async def update_person_api(person_id: int, person_update_data: PersonUpdate):
    update_data = person_update_data.dict(exclude_unset=True)
    if not update_data:
        raise HTTPException(status_code=400, detail="No update data provided.")
    try:
        # If email is being updated, check if the new email already exists for another person
        if "email" in update_data:
            existing_person_with_new_email = await db_service_pg.get_person_by_email_from_db(update_data["email"])
            if existing_person_with_new_email and existing_person_with_new_email["person_id"] != person_id:
                raise HTTPException(status_code=409, detail=f"Email {update_data['email']} already in use by another person.")

        updated_db_person = await db_service_pg.update_person_in_db(person_id, update_data)
        if not updated_db_person:
            raise HTTPException(status_code=404, detail=f"Person with ID {person_id} not found or update failed.")
        return PersonInDB(**updated_db_person)
    except asyncpg.exceptions.UniqueViolationError: # Catch UniqueViolation specifically if not caught in db_service
         raise HTTPException(status_code=409, detail=f"Update failed: email {update_data.get('email')} may already exist for another person (unique constraint). ")
    except Exception as e:
        logger.exception(f"Error in update_person_api for ID {person_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/people/{person_id}", status_code=204, summary="Delete Person", tags=["People"])
async def delete_person_api(person_id: int):
    try:
        success = await db_service_pg.delete_person_from_db(person_id)
        if not success:
            raise HTTPException(status_code=404, detail=f"Person with ID {person_id} not found or delete failed.")
        return # Returns 204 No Content on success
    except Exception as e:
        logger.exception(f"Error in delete_person_api for ID {person_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.put("/people/{person_id}/set-password", status_code=204, summary="Set or Change Person's Dashboard Password", tags=["People"])
async def set_person_password_api(person_id: int, password_data: PersonSetPassword):
    """
    Sets or changes the dashboard password for a specified person.
    The password will be hashed before being stored.
    """
    # 1. Verify person exists (optional, db update will fail if not found anyway but good for clear error)
    person_exists = await db_service_pg.get_person_by_id_from_db(person_id)
    if not person_exists:
        raise HTTPException(status_code=404, detail=f"Person with ID {person_id} not found.")

    # 2. Hash the new password
    hashed_password_value = hash_password(password_data.password)

    # 3. Update only the dashboard_password_hash in the database
    # This requires a new function in db_service_pg.py or modification of the existing update
    try:
        success = await db_service_pg.update_person_password_hash(person_id, hashed_password_value)
        if not success:
            # This case might indicate person_id not found by the update query itself
            raise HTTPException(status_code=404, detail="Person not found or password update failed at DB level.") 
    except Exception as e:
        logger.exception(f"Error setting password for person ID {person_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to set password: {str(e)}")
    
    logger.info(f"Password updated successfully for person ID: {person_id}")
    return # Return 204 No Content

# --- MatchSuggestion CRUD Endpoints ---

@app.post("/match-suggestions/", response_model=MatchSuggestionInDB, status_code=201, summary="Create New Match Suggestion", tags=["Match Suggestions"])
async def create_match_suggestion_api(suggestion_data: MatchSuggestionCreate):
    suggestion_dict = suggestion_data.dict()
    try:
        # Optional: Check if a suggestion for this campaign_id and media_id already exists to prevent duplicates
        # existing = await db_service_pg.get_match_suggestion_by_campaign_media(suggestion_data.campaign_id, suggestion_data.media_id)
        # if existing: 
        #     raise HTTPException(status_code=409, detail="Match suggestion for this campaign and media already exists.")
        
        created_db_suggestion = await db_service_pg.create_match_suggestion_in_db(suggestion_dict)
        if not created_db_suggestion:
            raise HTTPException(status_code=500, detail="Failed to create match suggestion in database.")
        return MatchSuggestionInDB(**created_db_suggestion)
    except Exception as e:
        logger.exception(f"Error in create_match_suggestion_api: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/match-suggestions/campaign/{campaign_id}", response_model=List[MatchSuggestionInDB], summary="List Match Suggestions for a Campaign", tags=["Match Suggestions"])
async def list_match_suggestions_for_campaign_api(campaign_id: uuid.UUID, skip: int = 0, limit: int = 100):
    try:
        suggestions_from_db = await db_service_pg.get_match_suggestions_for_campaign_from_db(campaign_id, skip=skip, limit=limit)
        return [MatchSuggestionInDB(**s) for s in suggestions_from_db]
    except Exception as e:
        logger.exception(f"Error in list_match_suggestions_for_campaign_api for campaign {campaign_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/match-suggestions/{match_id}", response_model=MatchSuggestionInDB, summary="Get Specific Match Suggestion by ID", tags=["Match Suggestions"])
async def get_match_suggestion_api(match_id: int):
    try:
        suggestion_from_db = await db_service_pg.get_match_suggestion_by_id_from_db(match_id)
        if not suggestion_from_db:
            raise HTTPException(status_code=404, detail=f"Match suggestion with ID {match_id} not found.")
        return MatchSuggestionInDB(**suggestion_from_db)
    except Exception as e:
        logger.exception(f"Error in get_match_suggestion_api for ID {match_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.put("/match-suggestions/{match_id}", response_model=MatchSuggestionInDB, summary="Update Match Suggestion", tags=["Match Suggestions"])
async def update_match_suggestion_api(match_id: int, suggestion_update_data: MatchSuggestionUpdate):
    update_data = suggestion_update_data.dict(exclude_unset=True)
    if not update_data: # If empty dict is passed, no fields to update
        existing_suggestion = await db_service_pg.get_match_suggestion_by_id_from_db(match_id)
        if not existing_suggestion:
            raise HTTPException(status_code=404, detail=f"Match suggestion with ID {match_id} not found.")
        return MatchSuggestionInDB(**existing_suggestion)
        
    try:
        updated_db_suggestion = await db_service_pg.update_match_suggestion_in_db(match_id, update_data)
        if not updated_db_suggestion:
            raise HTTPException(status_code=404, detail=f"Match suggestion with ID {match_id} not found or update failed.")
        return MatchSuggestionInDB(**updated_db_suggestion)
    except Exception as e:
        logger.exception(f"Error in update_match_suggestion_api for ID {match_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/match-suggestions/{match_id}", status_code=204, summary="Delete Match Suggestion", tags=["Match Suggestions"])
async def delete_match_suggestion_api(match_id: int):
    try:
        success = await db_service_pg.delete_match_suggestion_from_db(match_id)
        if not success:
            raise HTTPException(status_code=404, detail=f"Match suggestion with ID {match_id} not found or delete failed.")
        return # Returns 204 No Content on success
    except Exception as e:
        logger.exception(f"Error in delete_match_suggestion_api for ID {match_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# To run: `uvicorn internal_dashboard_api.internal_dashboard_api:app --reload` (from project root)
# Ensure db_service_pg.py, angles_processor_pg.py are in python path (e.g. project root or src/)
# 5. Access API docs at http://127.0.0.1:8000/docs 